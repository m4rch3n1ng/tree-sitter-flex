==================
basic
==================

%{
#include "yy.tab.h"
%}

%option noyywrap

digit   [0-9]

%%

%%

------------------

(source_file
  (code_block
    (embedded_code))
  (directive
    (identifier)
    (value))
  (definition
    (identifier)
    (pattern
      (bracketed))))

==================
comments
==================

/* a comment */

letter [a-zA-Z]

%{
#include "y.tab.h"
%}

%p /* one */ /* two */ 6000 /* set positions to 6000 */
/* another comment */
%option noyywrap 
%set

/* the following is technically not valid, but pretty common while writing */
digit

/* even more comments wow */

%%

"+"      /* + */ /* + */  { return PLUS;    } /* - */
"-"      /* - */          { return MINUS;   } /* + */
  /* */
"//"(?#comment).+         { return COMMENT; }
  /* one
  two */ /*
  three */
\n
[ \t\r]                   /* skip whitespace */

%%

------------------

(source_file
  (comment)
  (definition
    (identifier)
    (pattern
      (bracketed)))
  (code_block
    (embedded_code))
  (directive
    (identifier)
    (comment)
    (comment)
    (value)
    (comment))
  (comment)
  (directive
    (identifier)
    (value))
  (directive
    (identifier))
  (comment)
  (definition
    (identifier))
  (comment)
  (rule
    (pattern
      (string))
    (embedded_code))
  (rule
    (pattern
      (string))
    (embedded_code))
  (comment)
  (rule
    (pattern
      (string)
      (comment))
    (embedded_code))
  (comment)
  (comment)
  (rule
    (pattern
      (escaped)))
  (rule
    (pattern
      (bracketed
        (escaped)
        (escaped)))
    (embedded_code)))

==================
embedded_code
==================

%option noyywrap

%{
#include "y.tab.h"

char *test = "%}"
%}

%top{
#include <stdlib.h>
}

%e 4000
digit [0-9]

%{
int lineno = 0;
%}

%p 6000 /* set positions to 6000 */

%%

    ++lineno;
    if (true)
      --lineno;

""                   { return THE_VOID; }
"+"                  { return PLUS;     } lineno += 1;

%%

int thing() {
    return true;
}

------------------

(source_file
  (directive
    (identifier)
    (value))
  (code_block
    (embedded_code))
  (top_block
    (embedded_code))
  (directive
    (identifier)
    (value))
  (definition
    (identifier)
    (pattern
      (bracketed)))
  (code_block
    (embedded_code))
  (directive
    (identifier)
    (value)
    (comment))
  (embedded_code)
  (embedded_code)
  (embedded_code)
  (rule
    (pattern
      (string))
    (embedded_code))
  (rule
    (pattern
      (string))
    (embedded_code))
  (embedded_code))

==================
states
==================

%{
#include "y.tab.h"
%}

%x COMMENT

%%


"/*"                       { BEGIN(COMMENT); }
<*>[ \t]                   /* ignore */
<COMMENT>([^*]|\*[^/])*    /* ignore */
<COMMENT,INITIAL>\n.*      { yycolumn = 1;
                             yyless(1); }
<COMMENT>"*/"              { BEGIN(INITIAL); }
<COMMENT><<EOF>>           REJECT

%%

------------------

(source_file
  (code_block
    (embedded_code))
  (directive
    (identifier)
    (value))
  (rule
    (pattern
      (string))
    (embedded_code))
  (condition
    (rule
      (pattern
        (bracketed
          (escaped)))
      (embedded_code)))
  (condition
    (identifier)
    (rule
      (pattern
        (bracketed)
        (escaped)
        (bracketed))
      (embedded_code)))
  (condition
    (identifier)
    (identifier)
    (rule
      (pattern
        (escaped))
      (embedded_code)))
  (condition
    (identifier)
    (rule
      (pattern
        (string))
      (embedded_code)))
  (condition
    (identifier)
    (rule
      (pattern
        (eof))
      (embedded_code))))

==================
more complex rules
==================

digit         [0-9]
letter        [a-zA-Z]

%%

[]              /* technically not valid, but a pretty common state while typing */
{digit}{0,9}\.{digit}+      { return FLOAT; }
[ \t]                       { return WHITESPACE; }
"[xyz]\"foo"                REJECT;
{letter}({letter}|{digit})* {
                       if (true) {
                           yylval.id = strdup(yytext);
                       }
                       return IDENT;      }

"/*"\123|\x2a               BEGIN(IN_COMMENT);
^{digit}^{digit}|$\.$  /* not even sure */
<<EOF>>                /* ignore */
t{1,}x{2}              ECHO;

%%

------------------

(source_file
  (definition
    (identifier)
    (pattern
      (bracketed)))
  (definition
    (identifier)
    (pattern
      (bracketed)))
  (rule
    (pattern
      (bracketed))
    (embedded_code))
  (rule
    (pattern
      (expansion
        (identifier))
      (quantifier
        (number)
        (number))
      (escaped)
      (expansion
        (identifier)))
    (embedded_code))
  (rule
    (pattern
      (bracketed
        (escaped)))
    (embedded_code))
  (rule
    (pattern
      (string
        (escaped)))
    (embedded_code))
  (rule
    (pattern
      (expansion
        (identifier))
      (expansion
        (identifier))
      (expansion
        (identifier)))
    (embedded_code))
  (rule
    (pattern
      (string)
      (escaped)
      (escaped))
    (embedded_code))
  (rule
    (pattern
      (expansion
        (identifier))
      (expansion
        (identifier))
      (token)
      (escaped))
    (embedded_code))
  (rule
    (pattern
      (eof))
    (embedded_code))
  (rule
    (pattern
      (quantifier
        (number))
      (quantifier
        (number)))
    (embedded_code)))

==================
multiline state
==================

%%

<INITIAL>{
"/*"      BEGIN(IN_COMMENT);
}
<IN_COMMENT>{
"*/"      BEGIN(INITIAL);
[^*\n]+   // eat comment in chunks
"*"       // eat the lone star
\n        yylineno++;
}

%%

------------------

(source_file
  (condition
    (identifier)
    (rule
      (pattern
        (string))
      (embedded_code)))
  (condition
    (identifier)
    (rule
      (pattern
        (string))
      (embedded_code))
    (rule
      (pattern
        (bracketed
          (escaped)))
      (embedded_code))
    (rule
      (pattern
        (string))
      (embedded_code))
    (rule
      (pattern
        (escaped))
      (embedded_code))))

==================
incomplete 02
==================

digit [0-9]

%%

{digit}\.{digit}

------------------

(source_file
  (definition
    (identifier)
    (pattern
      (bracketed)))
  (rule
    (pattern
      (expansion
        (identifier))
      (escaped)
      (expansion
        (identifier)))))

==================
incomplete 01
==================

digit [0-9]

------------------

(source_file
  (definition
    (identifier)
    (pattern
      (bracketed))))
